nextflow_workflow {

    name "Test REALTIME_MONITORING"
    script "../../realtime_monitoring.nf"
    workflow "REALTIME_MONITORING"

    test("Should handle disabled real-time mode gracefully") {

        when {
            workflow {
                """
                input[0] = '$outputDir/test_watch_dir'     // watch_dir
                input[1] = '**/*.fastq{,.gz}'              // file_pattern
                input[2] = 5                               // batch_size
                input[3] = '2.min'                         // batch_interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = null
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            
            // When realtime_mode is false, should return empty channels
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should validate parameters for real-time FASTQ monitoring") {

        setup {
            """
            # Create test watch directory structure
            mkdir -p $outputDir/fastq_watch_dir
            mkdir -p $outputDir/fastq_watch_dir/subdir1
            mkdir -p $outputDir/fastq_watch_dir/subdir2
            
            # Create mock FASTQ files to simulate real structure
            echo "@read1\nATCGATCGATCG\n+\nIIIIIIIIIIII" > $outputDir/fastq_watch_dir/sample1.fastq
            echo "@read2\nGCTAGCTAGCTA\n+\nIIIIIIIIIIII" > $outputDir/fastq_watch_dir/sample2.fastq.gz
            echo "@read3\nTAGCTAGCTAGC\n+\nIIIIIIIIIIII" > $outputDir/fastq_watch_dir/subdir1/sample3.fastq
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/fastq_watch_dir'    // watch_dir
                input[1] = '**/*.fastq{,.gz}'              // file_pattern
                input[2] = 3                               // batch_size
                input[3] = '1.min'                         // batch_interval
                """
            }
            
            params {
                realtime_mode = true
                max_files = "5" // Limit for testing
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '2.min'
            }
        }

        then {
            // Note: This test validates parameter setup, but actual watchPath
            // functionality is difficult to test in nf-test environment
            // The workflow should initialize correctly
            assert workflow.success
            
            // Check that the workflow handles the parameter configuration
            assert workflow.duration.toMillis() < 120000 // Should complete quickly
        }
    }

    test("Should handle different file patterns correctly") {

        setup {
            """
            # Create FASTQ files with different extensions and naming patterns
            mkdir -p $outputDir/pattern_test_dir
            echo "@read1\nATCG\n+\nIIII" > $outputDir/pattern_test_dir/sample1.fastq
            echo "@read2\nGCTA\n+\nIIII" > $outputDir/pattern_test_dir/sample2.fq
            echo "@read3\nTAGC\n+\nIIII" > $outputDir/pattern_test_dir/sample3.fastq.gz
            echo "@read4\nCGAT\n+\nIIII" > $outputDir/pattern_test_dir/sample4.fq.gz
            echo "Not FASTQ" > $outputDir/pattern_test_dir/sample.txt
            echo "Not FASTQ" > $outputDir/pattern_test_dir/sample.pod5
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/pattern_test_dir'   // watch_dir
                input[1] = '*.fastq'                       // file_pattern - only .fastq extension
                input[2] = 2                               // batch_size
                input[3] = '30.sec'                        // batch_interval
                """
            }
            
            params {
                realtime_mode = false  // Disable for static testing
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            
            // When disabled, should return empty channels
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should handle different batch sizes correctly") {

        setup {
            """
            # Create multiple FASTQ files for batch testing
            mkdir -p $outputDir/batch_test_dir
            for i in {1..10}; do
                echo "@read$i\nATCGATCGATCG\n+\nIIIIIIIIIIII" > $outputDir/batch_test_dir/batch_$(printf "%03d" $i).fastq
            done
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/batch_test_dir'     // watch_dir
                input[1] = '**/*.fastq'                    // file_pattern
                input[2] = 1                               // batch_size - single file batches
                input[3] = '10.sec'                        // batch_interval
                """
            }
            
            params {
                realtime_mode = false  // Static mode for testing
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            
            // Verify batch configuration is handled
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0  // Empty when disabled
            }
        }
    }

    test("Should handle large batch sizes") {

        setup {
            """
            # Create scenario for large batches
            mkdir -p $outputDir/large_batch_dir
            for i in {1..50}; do
                echo "@read$i\nATCGATCGATCGATCGATCG\n+\nIIIIIIIIIIIIIIIIIIII" > $outputDir/large_batch_dir/large_batch_$(printf "%03d" $i).fastq
            done
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/large_batch_dir'    // watch_dir
                input[1] = '**/*.fastq'                    // file_pattern
                input[2] = 25                              // batch_size - large batches
                input[3] = '5.min'                         // batch_interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = "100" // High limit
                max_cpus = 4
                max_memory = '8.GB'
                max_time = '5.min'
            }
        }

        then {
            assert workflow.success
            
            // Verify large batch handling
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should handle different batch intervals") {

        setup {
            """
            # Create FASTQ files for interval testing
            mkdir -p $outputDir/interval_test_dir
            for i in 1 2 3 4 5; do
                echo "@read$i\nATCGATCGATCG\n+\nIIIIIIIIIIII" > $outputDir/interval_test_dir/interval_$i.fastq
            done
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/interval_test_dir'  // watch_dir
                input[1] = '**/*.fastq'                    // file_pattern
                input[2] = 3                               // batch_size
                input[3] = '30.sec'                        // batch_interval - short interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = "1"
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            
            // Interval configuration validation
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should handle nested directory structures") {

        setup {
            """
            # Create complex nested directory structure
            mkdir -p $outputDir/nested_test/level1/level2/level3
            mkdir -p $outputDir/nested_test/another_branch/subbranch
            
            # Place FASTQ files at different levels
            echo "@read1\nATCG\n+\nIIII" > $outputDir/nested_test/root.fastq
            echo "@read2\nGCTA\n+\nIIII" > $outputDir/nested_test/level1/level1.fastq
            echo "@read3\nTAGC\n+\nIIII" > $outputDir/nested_test/level1/level2/level2.fastq
            echo "@read4\nCGAT\n+\nIIII" > $outputDir/nested_test/level1/level2/level3/level3.fastq
            echo "@read5\nATGC\n+\nIIII" > $outputDir/nested_test/another_branch/branch.fastq
            echo "@read6\nGCAT\n+\nIIII" > $outputDir/nested_test/another_branch/subbranch/subbranch.fastq
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/nested_test'        // watch_dir
                input[1] = '**/*.fastq'                    // file_pattern - recursive search
                input[2] = 4                               // batch_size
                input[3] = '2.min'                         // batch_interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = "2"
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '2.min'
            }
        }

        then {
            assert workflow.success
            
            // Nested directory handling validation
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should handle empty watch directories") {

        setup {
            """
            # Create empty watch directory
            mkdir -p $outputDir/empty_watch_dir
            mkdir -p $outputDir/empty_watch_dir/subdir1
            mkdir -p $outputDir/empty_watch_dir/subdir2
            
            # No FASTQ files - only create other file types
            echo "Not a FASTQ file" > $outputDir/empty_watch_dir/readme.txt
            echo "Also not FASTQ" > $outputDir/empty_watch_dir/data.csv
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/empty_watch_dir'    // watch_dir
                input[1] = '**/*.fastq'                    // file_pattern
                input[2] = 5                               // batch_size
                input[3] = '1.min'                         // batch_interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = "0" // No files expected
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            
            // Empty directory handling
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should handle different FASTQ file formats") {

        setup {
            """
            # Create FASTQ files with different formats and compressions
            mkdir -p $outputDir/format_test_dir
            
            # Standard FASTQ
            echo "@read1\nATCGATCGATCG\n+\nIIIIIIIIIIII" > $outputDir/format_test_dir/standard.fastq
            
            # Compressed FASTQ
            echo "@read2\nGCTAGCTAGCTA\n+\nIIIIIIIIIIII" | gzip > $outputDir/format_test_dir/compressed.fastq.gz
            
            # FQ extension
            echo "@read3\nTAGCTAGCTAGC\n+\nIIIIIIIIIIII" > $outputDir/format_test_dir/alternative.fq
            
            # Compressed FQ
            echo "@read4\nCGATCGATCGAT\n+\nIIIIIIIIIIII" | gzip > $outputDir/format_test_dir/compressed_alt.fq.gz
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/format_test_dir'    // watch_dir
                input[1] = '**/*.{fastq,fq}{,.gz}'         // file_pattern - multiple formats
                input[2] = 2                               // batch_size
                input[3] = '1.min'                         // batch_interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = "1"
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '2.min'
            }
        }

        then {
            assert workflow.success
            
            // Format handling validation
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should validate resource requirements for different scenarios") {

        setup {
            """
            # Create resource-intensive scenario
            mkdir -p $outputDir/resource_test_dir
            for i in {1..100}; do
                echo "@read$i\nATCGATCGATCGATCGATCGATCGATCGATCGATCG\n+\nIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII" > $outputDir/resource_test_dir/resource_$(printf "%04d" $i).fastq
            done
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/resource_test_dir'  // watch_dir
                input[1] = '**/*.fastq'                    // file_pattern
                input[2] = 50                              // batch_size - large batches
                input[3] = '10.min'                        // batch_interval - long interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = "20"
                max_cpus = 8
                max_memory = '16.GB'
                max_time = '10.min'
            }
        }

        then {
            assert workflow.success
            
            // Resource requirement validation
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
            
            // Should handle high resource scenarios
            assert workflow.duration.toMillis() < 180000 // Less than 3 minutes
        }
    }

    test("Should handle files with special characters in names") {

        setup {
            """
            # Create FASTQ files with special characters
            mkdir -p $outputDir/special_chars_dir
            echo "@read1\nATCG\n+\nIIII" > '$outputDir/special_chars_dir/sample-1_test.fastq'
            echo "@read2\nGCTA\n+\nIIII" > '$outputDir/special_chars_dir/sample@2_test.fastq'
            echo "@read3\nTAGC\n+\nIIII" > '$outputDir/special_chars_dir/sample#3_test.fastq'
            echo "@read4\nCGAT\n+\nIIII" > '$outputDir/special_chars_dir/sample%4_test.fastq'
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/special_chars_dir'  // watch_dir
                input[1] = '**/*.fastq'                    // file_pattern
                input[2] = 2                               // batch_size
                input[3] = '1.min'                         // batch_interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = "1"
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            
            // Special character handling
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should handle very long file paths") {

        setup {
            """
            # Create FASTQ files with very long names
            mkdir -p $outputDir/long_names_dir
            echo "@read1\nATCG\n+\nIIII" > '$outputDir/long_names_dir/very_very_long_sample_name_with_lots_of_metadata_information_and_detailed_annotations.fastq'
            echo "@read2\nGCTA\n+\nIIII" > '$outputDir/long_names_dir/extremely_detailed_nanopore_sequencing_sample_with_comprehensive_naming_convention.fastq'
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/long_names_dir'     // watch_dir
                input[1] = '**/*.fastq'                    // file_pattern
                input[2] = 1                               // batch_size
                input[3] = '1.min'                         // batch_interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = 5
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            
            // Long path handling
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }

    test("Should validate file pattern matching precision") {

        setup {
            """
            # Create files that should and shouldn't match patterns
            mkdir -p $outputDir/pattern_precision_dir
            
            # Should match
            echo "@read1\nATCG\n+\nIIII" > $outputDir/pattern_precision_dir/sample1.fastq
            echo "@read2\nGCTA\n+\nIIII" > $outputDir/pattern_precision_dir/sample2.fq
            
            # Should not match
            echo "Not FASTQ" > $outputDir/pattern_precision_dir/sample1.fastq.bak
            echo "Not FASTQ" > $outputDir/pattern_precision_dir/sample2.fq.old
            echo "Not FASTQ" > $outputDir/pattern_precision_dir/fastq_sample.txt
            echo "Not FASTQ" > $outputDir/pattern_precision_dir/sample.fast
            """
        }

        when {
            workflow {
                """
                input[0] = '$outputDir/pattern_precision_dir'  // watch_dir
                input[1] = '*.{fastq,fq}'                      // file_pattern - precise matching
                input[2] = 5                                   // batch_size
                input[3] = '1.min'                             // batch_interval
                """
            }
            
            params {
                realtime_mode = false
                max_files = "1"
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            
            // Pattern precision validation
            if (workflow.out.samples) {
                def samples = workflow.out.samples.toList()
                assert samples.size() == 0
            }
        }
    }
}