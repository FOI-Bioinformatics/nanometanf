nextflow_workflow {

    name "Test QC_BENCHMARK"
    script "../../qc_benchmark.nf"
    workflow "QC_BENCHMARK"

    test("Should perform basic QC benchmarking with FASTP, FILTLONG, and CHOPPER") {

        setup {
            """
            # Create test FASTQ data for benchmarking
            mkdir -p $outputDir/benchmark_input
            cat > $outputDir/benchmark_input/test_reads.fastq << 'EOF'
@read1
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@read2
GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@read3
TAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGC
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
EOF
            """
        }

        when {
            workflow {
                """
                input[0] = Channel.of([
                    [id: 'benchmark_sample', single_end: true],
                    file('$outputDir/benchmark_input/test_reads.fastq')
                ])
                """
            }
            
            params {
                enable_qc_benchmark = true
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '5.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.benchmark_results
            assert workflow.out.fastp_results
            assert workflow.out.filtlong_results
            assert workflow.out.chopper_results
            assert workflow.out.enhanced_results
            assert workflow.out.nanoplot_reports
            assert workflow.out.versions

            // Verify all QC tools were tested
            def benchmark_results = workflow.out.benchmark_results.toList()
            assert benchmark_results.size() >= 4  // fastp, filtlong, chopper, porechop+filtlong

            // Verify NanoPlot reports for visualization
            def nanoplot_reports = workflow.out.nanoplot_reports.toList()
            assert nanoplot_reports.size() >= 4

            // Check that different QC strategies were benchmarked
            def fastp_results = workflow.out.fastp_results.toList()
            assert fastp_results.size() >= 1

            def filtlong_results = workflow.out.filtlong_results.toList()
            assert filtlong_results.size() >= 1

            def chopper_results = workflow.out.chopper_results.toList()
            assert chopper_results.size() >= 1

            def enhanced_results = workflow.out.enhanced_results.toList()
            assert enhanced_results.size() >= 1
        }
    }

    test("Should compare multiple QC tool performances") {

        setup {
            """
            # Create diverse test data for comprehensive benchmarking
            mkdir -p $outputDir/comparison_input
            
            # High-quality reads
            cat > $outputDir/comparison_input/high_quality.fastq << 'EOF'
@hq_read1
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@hq_read2
GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
EOF
            
            # Mixed quality reads
            cat > $outputDir/comparison_input/mixed_quality.fastq << 'EOF'
@mq_read1
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@mq_read2
GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIII!!!!!!!!!!!!!!IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
EOF
            """
        }

        when {
            workflow {
                """
                input[0] = Channel.fromList([
                    [
                        [id: 'comparison_hq', single_end: true],
                        file('$outputDir/comparison_input/high_quality.fastq')
                    ],
                    [
                        [id: 'comparison_mq', single_end: true], 
                        file('$outputDir/comparison_input/mixed_quality.fastq')
                    ]
                ])
                """
            }
            
            params {
                enable_qc_benchmark = true
                max_cpus = 4
                max_memory = '8.GB'
                max_time = '8.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.benchmark_results
            
            // Verify benchmarking for both samples
            def benchmark_results = workflow.out.benchmark_results.toList()
            assert benchmark_results.size() >= 8  // 4 tools Ã— 2 samples

            // Check that all benchmark categories are represented
            def tool_categories = benchmark_results.collect { it[0].benchmark_category }.unique()
            assert tool_categories.contains('general_purpose')
            assert tool_categories.contains('nanopore_optimized')
            assert tool_categories.contains('nanopore_native_rust')
            assert tool_categories.contains('enhanced_nanopore')
        }
    }

    test("Should handle QC benchmarking with different tool configurations") {

        setup {
            """
            # Create test data for tool configuration testing
            mkdir -p $outputDir/config_test_input
            cat > $outputDir/config_test_input/config_test.fastq << 'EOF'
@config_read1
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
EOF
            """
        }

        when {
            workflow {
                """
                input[0] = Channel.of([
                    [id: 'config_test_sample', single_end: true],
                    file('$outputDir/config_test_input/config_test.fastq')
                ])
                """
            }
            
            params {
                enable_qc_benchmark = true
                // Custom FASTP parameters for benchmarking
                fastp_extra_args = '--cut_tail --cut_tail_window_size 4 --cut_tail_mean_quality 20'
                // Custom FILTLONG parameters
                filtlong_min_length = 1000
                filtlong_min_quality = 85
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '5.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.benchmark_results
            assert workflow.out.fastp_results
            assert workflow.out.filtlong_results
            
            // Verify configuration-specific benchmarking
            def benchmark_results = workflow.out.benchmark_results.toList()
            assert benchmark_results.size() >= 3
        }
    }

    test("Should generate performance metrics and recommendations") {

        setup {
            """
            # Create performance testing data
            mkdir -p $outputDir/performance_input
            cat > $outputDir/performance_input/performance_test.fastq << 'EOF'
@perf_read1
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@perf_read2
GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@perf_read3
TAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGC
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@perf_read4
CGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAT
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@perf_read5
AGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAGT
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
EOF
            """
        }

        when {
            workflow {
                """
                input[0] = Channel.of([
                    [id: 'performance_sample', single_end: true],
                    file('$outputDir/performance_input/performance_test.fastq')
                ])
                """
            }
            
            params {
                enable_qc_benchmark = true
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '5.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.benchmark_results
            assert workflow.out.nanoplot_reports
            assert workflow.out.versions
            
            // Verify performance analysis outputs
            def benchmark_results = workflow.out.benchmark_results.toList()
            assert benchmark_results.size() >= 3
            
            // Verify all benchmarking tools completed
            def tool_names = benchmark_results.collect { it[0].qc_tool }.unique()
            assert tool_names.contains('fastp')
            assert tool_names.contains('filtlong')
            assert tool_names.contains('porechop_filtlong')
            
            // Verify NanoPlot visualization for all tools
            def nanoplot_reports = workflow.out.nanoplot_reports.toList()
            assert nanoplot_reports.size() >= 3
        }
    }

    test("Should handle empty input gracefully") {

        when {
            workflow {
                """
                input[0] = Channel.empty()
                """
            }
            
            params {
                enable_qc_benchmark = true
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            
            // Should handle empty input gracefully
            if (workflow.out.benchmark_results) {
                def benchmark_results = workflow.out.benchmark_results.toList()
                assert benchmark_results.size() == 0
            }
            
            if (workflow.out.fastp_results) {
                def fastp_results = workflow.out.fastp_results.toList()
                assert fastp_results.size() == 0
            }
            
            if (workflow.out.filtlong_results) {
                def filtlong_results = workflow.out.filtlong_results.toList()
                assert filtlong_results.size() == 0
            }
        }
    }

    test("Should validate QC benchmark resource requirements") {

        setup {
            """
            # Create resource-intensive test data
            mkdir -p $outputDir/resource_test_input
            for i in {1..10}; do
                cat >> $outputDir/resource_test_input/resource_test.fastq << EOF
@resource_read_\$i
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
EOF
            done
            """
        }

        when {
            workflow {
                """
                input[0] = Channel.of([
                    [id: 'resource_test_sample', single_end: true],
                    file('$outputDir/resource_test_input/resource_test.fastq')
                ])
                """
            }
            
            params {
                enable_qc_benchmark = true
                max_cpus = 4
                max_memory = '8.GB'
                max_time = '8.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.benchmark_results
            
            // Verify resource-intensive benchmarking
            def benchmark_results = workflow.out.benchmark_results.toList()
            assert benchmark_results.size() >= 3
            
            // Should handle resource-intensive processing efficiently
            assert workflow.duration.toMillis() < 480000 // Less than 8 minutes
        }
    }

    test("Should validate QC tool comparison accuracy") {

        setup {
            """
            # Create controlled test data for accuracy validation
            mkdir -p $outputDir/accuracy_test_input
            cat > $outputDir/accuracy_test_input/accuracy_test.fastq << 'EOF'
@accurate_read1
ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@accurate_read2
GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA
+
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII
@low_quality_read
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
+
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
EOF
            """
        }

        when {
            workflow {
                """
                input[0] = Channel.of([
                    [id: 'accuracy_test_sample', single_end: true],
                    file('$outputDir/accuracy_test_input/accuracy_test.fastq')
                ])
                """
            }
            
            params {
                enable_qc_benchmark = true
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '5.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.benchmark_results
            assert workflow.out.fastp_results
            assert workflow.out.filtlong_results
            assert workflow.out.enhanced_results
            
            // Verify accuracy testing completed
            def benchmark_results = workflow.out.benchmark_results.toList()
            assert benchmark_results.size() >= 3
            
            // Verify all QC approaches were tested
            def qc_tools = benchmark_results.collect { it[0].qc_tool }.unique()
            assert qc_tools.size() >= 3
        }
    }
}