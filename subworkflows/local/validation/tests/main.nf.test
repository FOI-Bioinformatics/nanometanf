nextflow_workflow {

    name "Test VALIDATION"
    script "../main.nf"
    workflow "VALIDATION"

    test("Should perform basic BLAST sequence validation") {

        setup {
            """
            # Create test FASTA query file
            cat > $outputDir/query_sequences.fasta << 'EOF'
>test_sequence_1
ATGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAT
>test_sequence_2
ATGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAT
EOF
            """
        }

        when {
            workflow {
                """
                input[0] = [
                    [
                        [id: 'validation_test', single_end: true],
                        file('$outputDir/query_sequences.fasta')
                    ]
                ]
                input[1] = file('$projectDir/tests/fixtures/blast_db/test_db')
                """
            }
            
            params {
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '2.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.txt
            assert workflow.out.versions
            
            // Verify BLAST validation output
            def blast_results = workflow.out.txt.toList()
            assert blast_results.size() >= 1
            
            // Check versions output
            def versions = workflow.out.versions.toList()
            assert versions.size() >= 1
        }
    }

    test("Should handle multiple query sequences") {

        setup {
            """
            # Create multiple query sequences
            cat > $outputDir/multiple_queries.fasta << 'EOF'
>query_sequence_1
ATGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAT
>query_sequence_2
CGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATG
>query_sequence_3
GCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
>query_sequence_4
TCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGA
EOF
            """
        }

        when {
            workflow {
                """
                input[0] = [
                    [
                        [id: 'multi_query_test', single_end: true],
                        file('$outputDir/multiple_queries.fasta')
                    ]
                ]
                input[1] = file('$projectDir/tests/fixtures/blast_db/test_db')
                """
            }
            
            params {
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '3.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.txt
            
            // Verify processing of multiple sequences
            def blast_results = workflow.out.txt.toList()
            assert blast_results.size() >= 1
        }
    }

    test("Should process batch validation for multiple samples") {

        setup {
            """
            # Create multiple sample FASTA files
            cat > $outputDir/sample1_queries.fasta << 'EOF'
>sample1_seq1
ATGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAT
>sample1_seq2
CGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATG
EOF

            cat > $outputDir/sample2_queries.fasta << 'EOF'
>sample2_seq1
GCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG
>sample2_seq2
TCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGA
EOF

            cat > $outputDir/sample3_queries.fasta << 'EOF'
>sample3_seq1
GATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATC
EOF

            """
        }

        when {
            workflow {
                """
                input[0] = [
                    [
                        [id: 'batch_sample1', single_end: true],
                        file('$outputDir/sample1_queries.fasta')
                    ],
                    [
                        [id: 'batch_sample2', single_end: true],
                        file('$outputDir/sample2_queries.fasta')
                    ],
                    [
                        [id: 'batch_sample3', single_end: true],
                        file('$outputDir/sample3_queries.fasta')
                    ]
                ]
                input[1] = file('$projectDir/tests/fixtures/blast_db/test_db')
                """
            }
            
            params {
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '4.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.txt
            
            // Verify batch processing
            def blast_results = workflow.out.txt.toList()
            assert blast_results.size() >= 3
        }
    }

    test("Should handle different BLAST output formats") {

        setup {
            """
            # Create query with diverse sequences
            cat > $outputDir/format_queries.fasta << 'EOF'
>format_test_sequence
ATGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAT
EOF

            """
        }

        when {
            workflow {
                """
                input[0] = [
                    [
                        [id: 'format_test', single_end: true],
                        file('$outputDir/format_queries.fasta')
                    ]
                ]
                input[1] = file('$projectDir/tests/fixtures/blast_db/test_db')
                """
            }
            
            params {
                blast_outfmt = 6  // Tabular format
                blast_evalue = 1e-5
                blast_max_target_seqs = 50
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '2.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.txt
            
            // Verify format-specific output
            def blast_results = workflow.out.txt.toList()
            assert blast_results.size() >= 1
        }
    }

    test("Should validate sequences with stringent parameters") {

        setup {
            """
            # Create high-quality query sequences
            cat > $outputDir/stringent_queries.fasta << 'EOF'
>high_quality_sequence
ATGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAT
EOF

            """
        }

        when {
            workflow {
                """
                input[0] = [
                    [
                        [id: 'stringent_test', single_end: true],
                        file('$outputDir/stringent_queries.fasta')
                    ]
                ]
                input[1] = file('$projectDir/tests/fixtures/blast_db/test_db')
                """
            }
            
            params {
                blast_evalue = 1e-10       // Very stringent e-value
                blast_word_size = 28       // Larger word size
                blast_gapopen = 5          // Gap penalties
                blast_gapextend = 2
                blast_max_target_seqs = 10 // Fewer targets
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '2.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.txt
            
            // Verify stringent validation
            def blast_results = workflow.out.txt.toList()
            assert blast_results.size() >= 1
        }
    }

    test("Should handle empty query input gracefully") {

        when {
            workflow {
                """
                input[0] = []
                input[1] = file('$projectDir/assets/test_data')  // Use any existing directory
                """
            }
            
            params {
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '1.min'
            }
        }

        then {
            // Should handle empty input gracefully
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            
            if (workflow.success) {
                // Empty outputs expected
                if (workflow.out.txt) {
                    def blast_results = workflow.out.txt.toList()
                    assert blast_results.size() == 0
                }
            }
        }
    }

    test("Should validate with custom BLAST parameters") {

        setup {
            """
            # Create diverse query sequences for custom parameter testing
            cat > $outputDir/custom_queries.fasta << 'EOF'
>custom_sequence_1
ATGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGAT
>custom_sequence_2
CGCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATG
EOF

            """
        }

        when {
            workflow {
                """
                input[0] = [
                    [
                        [id: 'custom_test', single_end: true],
                        file('$outputDir/custom_queries.fasta')
                    ]
                ]
                input[1] = file('$projectDir/tests/fixtures/blast_db/test_db')
                """
            }
            
            params {
                blast_outfmt = "6 qseqid sseqid pident length mismatch gapopen qstart qend sstart send evalue bitscore"
                blast_task = "blastn"
                blast_dust = "yes"
                blast_penalty = -3
                blast_reward = 2
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '2.min'
            }
        }

        then {
            assert workflow.success
            assert snapshot(workflow.out.versions).match()
            assert workflow.out.txt
            
            // Verify custom parameter processing
            def blast_results = workflow.out.txt.toList()
            assert blast_results.size() >= 1
        }
    }
}