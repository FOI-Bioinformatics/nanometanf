nextflow_pipeline {

    name "Test integration of new subworkflows"
    ../main.nf"

    test("Should integrate dynamic resource allocation with main workflow {

        when {
            params {
                input = "$projectDir/tests/test_samplesheet.csv"
                outdir = "$outputDir/results"
                
                // Enable dynamic resource allocation
                enable_dynamic_resources = true
                resource_optimization_profile = "balanced"
                
                // Enable all dynamic resource features
                enable_input_analysis = true
                enable_resource_prediction = true
                enable_system_monitoring = true
                enable_resource_optimization = true
                enable_performance_feedback = true
                
                // Integration with main workflow
                adaptive_resource_scaling = true
                dynamic_cpu_scaling = true
                dynamic_memory_scaling = true
                
                // Standard workflow features
                use_dorado = false
                kraken2_db = null
                blast_validation = false
                realtime_mode = false
                
                // Resource limits
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '3.min'
            }
        }

        then {
            assert workflow.success
            
            // Dynamic resource allocation subworkflow should run
            assert workflow.trace.tasks().any { it.name.contains('DYNAMIC_RESOURCE_ALLOCATION') }
            
            // Individual resource modules should run
            assert workflow.trace.tasks().any { it.name.contains('ANALYZE_INPUT_CHARACTERISTICS') }
            assert workflow.trace.tasks().any { it.name.contains('PREDICT_RESOURCE_REQUIREMENTS') }
            assert workflow.trace.tasks().any { it.name.contains('OPTIMIZE_RESOURCE_ALLOCATION') }
            
            // Main workflow processing should occur with optimized resources
            assert workflow.trace.tasks().any { it.name.contains('FASTP') }
            assert workflow.trace.tasks().any { it.name.contains('NANOPLOT') }
            assert workflow.trace.tasks().any { it.name.contains('MULTIQC') }
            
            // Integration outputs should exist
            assert path("${outputDir}/results/fastp.exists()
            assert path("${outputDir}/results/nanoplot.exists()
            assert path("${outputDir}/results/multiqc.exists()
            assert path("${outputDir}/results/resource_analysis.exists()
            assert path("${outputDir}/results/dynamic_resources.exists()
            
            // Verify samples were processed with dynamic resources
            def processing_tasks = workflow.trace.tasks().findAll { 
                it.name.contains('FASTP') || it.name.contains('NANOPLOT')
            }
            assert processing_tasks.size() >= 2  // Multiple samples processed
        }
    }

    test("Should integrate enhanced real-time monitoring with workflow {

            // Create files for real-time monitoring
            cp $projectDir/tests/test_sample.fastq.gz $outputDir/realtime_integration/barcode01/reads_001.fastq.gz
            cp $projectDir/tests/test_sample.fastq.gz $outputDir/realtime_integration/barcode02/reads_001.fastq.gz
            cp $projectDir/tests/test_sample.fastq.gz $outputDir/realtime_integration/unclassified/reads_001.fastq.gz
        }

        when {
            params {
                input = "$projectDir/tests/empty_samplesheet.csv"
                outdir = "$outputDir/results"
                
                // Enable enhanced real-time monitoring
                realtime_mode = true
                nanopore_output_dir = "$outputDir/realtime_integration"
                file_pattern = "**/*.fastq{,.gz}"
                
                // Enhanced monitoring features
                enable_adaptive_batching = true
                enable_file_prioritization = true
                enable_performance_monitoring = true
                
                // Real-time statistics integration
                enable_quality_indicators = true
                enable_source_analysis = true
                enable_timing_analysis = true
                
                // Batch processing
                batch_size = 3
                max_files = 6
                
                // Statistics and reporting
                realtime_stats_interval = "5s"
                realtime_report_format = "html,json"
                generate_cumulative_stats = true
                
                // Integration with barcode discovery
                barcode_input_dir = "$outputDir/realtime_integration"
                
                // Disable other features
                use_dorado = false
                kraken2_db = null
                blast_validation = false
                
                // Resource limits
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '3.min'
            }
        }

        then {
            assert workflow.success
            
            // Enhanced real-time monitoring subworkflow should run
            assert workflow.trace.tasks().any { it.name.contains('ENHANCED_REALTIME_MONITORING') }
            
            // Real-time statistics subworkflow should run
            assert workflow.trace.tasks().any { it.name.contains('REALTIME_STATISTICS') }
            
            // Statistics modules should run
            assert workflow.trace.tasks().any { it.name.contains('GENERATE_SNAPSHOT_STATS') }
            assert workflow.trace.tasks().any { it.name.contains('UPDATE_CUMULATIVE_STATS') }
            assert workflow.trace.tasks().any { it.name.contains('GENERATE_REALTIME_REPORT') }
            
            // Barcode discovery should integrate
            assert workflow.trace.tasks().any { it.name.contains('BARCODE_DISCOVERY') }
            
            // Main workflow processing should occur
            assert workflow.trace.tasks().any { it.name.contains('FASTP') }
            
            // Integration outputs should exist
            assert path("${outputDir}/results/fastp.exists()
            assert path("${outputDir}/results/realtime_stats.exists()
            assert path("${outputDir}/results/realtime_reports.exists()
            assert path("${outputDir}/results/multiqc.exists()
            
            // Verify barcode-aware processing occurred
            def fastp_outputs = path("${outputDir}/results/fastp.list()
            def barcode_specific = fastp_outputs.findAll { 
                it.name.contains('barcode01') || it.name.contains('barcode02') || it.name.contains('unclassified')
            }
            assert barcode_specific.size() >= 2
        }
    }

    test("Should integrate both dynamic resources and real-time monitoring {

            // Create diverse files for both resource allocation and real-time monitoring
            cp $projectDir/tests/test_sample.fastq.gz $outputDir/full_integration/barcode01/small_reads.fastq.gz
            cat $projectDir/tests/test_sample.fastq.gz $projectDir/tests/test_sample.fastq.gz > $outputDir/full_integration/barcode02/large_reads.fastq.gz
            cp $projectDir/tests/test_sample.fastq.gz $outputDir/full_integration/barcode03/medium_reads.fastq.gz
        }

        when {
            params {
                input = "$projectDir/tests/empty_samplesheet.csv"
                outdir = "$outputDir/results"
                
                // Enable both major features
                enable_dynamic_resources = true
                realtime_mode = true
                
                // Dynamic resource allocation
                resource_optimization_profile = "high_throughput"
                enable_resource_prediction = true
                enable_system_monitoring = true
                enable_adaptive_batching = true
                
                // Enhanced real-time monitoring
                nanopore_output_dir = "$outputDir/full_integration"
                file_pattern = "**/*.fastq{,.gz}"
                enable_file_prioritization = true
                
                // Integration configuration
                batch_size = 3
                max_files = 6
                
                // Statistics and performance
                enable_performance_monitoring = true
                enable_quality_indicators = true
                realtime_stats_interval = "5s"
                enable_performance_feedback = true
                
                // Barcode discovery
                barcode_input_dir = "$outputDir/full_integration"
                
                // Priority configuration
                priority_samples = "barcode01,barcode02"
                
                // Disable other features
                use_dorado = false
                kraken2_db = null
                blast_validation = false
                
                // Resource limits
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '4.min'
            }
        }

        then {
            assert workflow.success
            
            // Both major subworkflows should run
            assert workflow.trace.tasks().any { it.name.contains('DYNAMIC_RESOURCE_ALLOCATION') }
            assert workflow.trace.tasks().any { it.name.contains('ENHANCED_REALTIME_MONITORING') }
            assert workflow.trace.tasks().any { it.name.contains('REALTIME_STATISTICS') }
            
            // Dynamic resource modules should run
            assert workflow.trace.tasks().any { it.name.contains('PREDICT_RESOURCE_REQUIREMENTS') }
            assert workflow.trace.tasks().any { it.name.contains('OPTIMIZE_RESOURCE_ALLOCATION') }
            
            // Real-time statistics modules should run
            assert workflow.trace.tasks().any { it.name.contains('GENERATE_SNAPSHOT_STATS') }
            assert workflow.trace.tasks().any { it.name.contains('GENERATE_REALTIME_REPORT') }
            
            // Barcode discovery should integrate
            assert workflow.trace.tasks().any { it.name.contains('BARCODE_DISCOVERY') }
            
            // Main processing with integrated features
            def fastp_tasks = workflow.trace.tasks().findAll { it.name.contains('FASTP') }
            assert fastp_tasks.size() >= 3  // All barcodes processed
            
            // All integration outputs should exist
            assert path("${outputDir}/results/fastp.exists()
            assert path("${outputDir}/results/resource_analysis.exists()
            assert path("${outputDir}/results/dynamic_resources.exists()
            assert path("${outputDir}/results/realtime_stats.exists()
            assert path("${outputDir}/results/realtime_reports.exists()
            assert path("${outputDir}/results/multiqc.exists()
            
            // Verify comprehensive integration worked
            def all_outputs = [
                path("${outputDir}/results/fastp.list(),
                path("${outputDir}/results/resource_analysis.list(),
                path("${outputDir}/results/realtime_stats.list()
            ].flatten()
            
            assert all_outputs.size() >= 6  // Multiple files across different output types
        }
    }

    test("Should integrate subworkflows with existing workflow features {

        when {
            params {
                input = "$projectDir/tests/test_samplesheet.csv"
                outdir = "$outputDir/results"
                
                // Enable new subworkflows
                enable_dynamic_resources = true
                resource_optimization_profile = "balanced"
                
                // Enable existing workflow features that should integrate
                use_dorado = false  // Keep disabled for speed
                kraken2_db = null   // Keep disabled for speed
                blast_validation = false  // Keep disabled for speed
                
                // Quality control (existing feature)
                skip_nanoplot = false
                skip_fastp = false
                
                // Integration with existing features
                enable_resource_prediction = true
                enable_system_monitoring = true
                enable_performance_monitoring = true
                
                // MultiQC integration
                skip_multiqc = false
                
                // Resource limits
                max_cpus = 2
                max_memory = '4.GB'
                max_time = '3.min'
            }
        }

        then {
            assert workflow.success
            
            // New subworkflows should run
            assert workflow.trace.tasks().any { it.name.contains('DYNAMIC_RESOURCE_ALLOCATION') }
            
            // Existing workflow features should run with integration
            assert workflow.trace.tasks().any { it.name.contains('FASTP') }
            assert workflow.trace.tasks().any { it.name.contains('NANOPLOT') }
            assert workflow.trace.tasks().any { it.name.contains('MULTIQC') }
            
            // Resource allocation should have occurred
            assert workflow.trace.tasks().any { it.name.contains('OPTIMIZE_RESOURCE_ALLOCATION') }
            
            // All expected outputs should exist
            assert path("${outputDir}/results/fastp.exists()
            assert path("${outputDir}/results/nanoplot.exists()
            assert path("${outputDir}/results/multiqc.exists()
            assert path("${outputDir}/results/resource_analysis.exists()
            
            // Verify integration didn't break existing functionality
            def multiqc_report = path("${outputDir}/results/multiqc.list().find { 
                it.name.endsWith('.html') 
            }
            assert multiqc_report != null  // MultiQC report should exist
        }
    }

    test("Should handle subworkflow integration edge cases {

        when {
            params {
                input = "$projectDir/tests/test_samplesheet.csv"
                outdir = "$outputDir/results"
                
                // Enable subworkflows with edge case configurations
                enable_dynamic_resources = true
                realtime_mode = false  // Disable real-time for this test
                
                // Minimal resource configuration
                resource_optimization_profile = "development_testing"
                min_cpu_allocation = 1
                min_memory_allocation = "1GB"
                
                // Conservative settings
                prediction_confidence_threshold = 0.9
                resource_safety_margin = 0.3
                
                // Edge case handling
                resource_allocation_timeout = "15s"
                fallback_resource_profile = "resource_conservative"
                
                // Disable other features
                use_dorado = false
                kraken2_db = null
                blast_validation = false
                
                // Minimal resource limits
                max_cpus = 1
                max_memory = '2.GB'
                max_time = '2.min'
            }
        }

        then {
            // Should handle edge cases gracefully
            assert workflow.success || workflow.failed
            
            if (workflow.success) {
                // If successful, minimal integration should work
                def resource_tasks = workflow.trace.tasks().findAll { 
                    it.name.contains('DYNAMIC_RESOURCE_ALLOCATION') || it.name.contains('RESOURCE')
                }
                assert resource_tasks.size() >= 0  // May be minimal
                
                // Basic processing should occur
                def processing_tasks = workflow.trace.tasks().findAll { it.name.contains('FASTP') }
                assert processing_tasks.size() >= 0
            }
            
            if (workflow.failed) {
                // Should fail relatively quickly if integration has issues
                assert workflow.duration.toMillis() < 150000  // Less than 2.5 minutes
            }
        }
    }

    test("Should validate subworkflow integration parameters {

        when {
            params {
                input = "$projectDir/tests/test_samplesheet.csv"
                outdir = "$outputDir/results"
                
                // Parameter validation without actual execution
                enable_dynamic_resources = false
                realtime_mode = false
                
                // Dynamic resource parameters to validate
                resource_optimization_profile = "balanced"
                enable_resource_prediction = true
                enable_system_monitoring = true
                adaptive_resource_scaling = true
                
                // Real-time monitoring parameters to validate
                nanopore_output_dir = "/tmp/test_realtime"
                file_pattern = "**/*.fastq{,.gz}"
                batch_size = 5
                enable_file_prioritization = true
                
                // Statistics parameters to validate
                realtime_stats_interval = "10s"
                enable_performance_monitoring = true
                generate_cumulative_stats = true
                
                // Integration parameters to validate
                enable_adaptive_batching = true
                enable_quality_indicators = true
                priority_samples = "sample1,sample2"
                
                // Disable actual processing
                use_dorado = false
                kraken2_db = null
                blast_validation = false
                
                // Quick validation
                max_cpus = 1
                max_memory = '1.GB'
                max_time = '30.s'
            }
        }

        then {
            assert workflow.success
            
            // Should not run subworkflows when disabled
            assert !workflow.trace.tasks().any { it.name.contains('DYNAMIC_RESOURCE_ALLOCATION') }
            assert !workflow.trace.tasks().any { it.name.contains('ENHANCED_REALTIME_MONITORING') }
            assert !workflow.trace.tasks().any { it.name.contains('REALTIME_STATISTICS') }
            
            // Parameter validation should succeed
            assert workflow.exitStatus == 0
        }
    }
}